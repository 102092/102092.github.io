[{"content":"1. 버그 내용  특정 시간만 되면 혹은 간헐적이나 지속적으로, Redis 운영에 장애가 생김. (약 10분 ~ 20분) Error Log -\u0026gt; ... Redis command timed out;  로그 내용으로 보아, 어떠한 이유에서 인 지 레디스 멈췄고, 다른 작업들을 처리하지 못해서 생기는 이슈 같음.    2. 생각해볼 수 있는 원인   특정 작업을 처리하는 데, 시간이 오래 걸려서, 레디스에서 병목이 생기는거 아닐까?\n slow log 찾아볼 것 SLOWLOG subcommand    특정 시간에 너무 많은 키가 expire 되어서 발생한 문제가 아닐까?\n 에러 발생한 시간 대, 키들의 expire 되고 있는 시간을 조절.    해당 시간 진행되는 작업 중, 발생하는 트랜잭션에서 뭔가 문제가 발생한 건 아닐까?\n 코드 점검 트랜잭션 진행되고 있는 코드 확인.    AWS EC2 instance issue 일수도..?\n 문서 를 참고하여, reboot -\u0026gt; stop and start 순으로 시도해보기.    3. 해결 시도   우선 팀에서 필요하다고 생각되는 부분을 개선.\n redis connection pool 조정. redis tcp-keepalive 조정을 통한 connection 확인. 추후 에러 빈도가 낮아지면, 사용 중인 라이브러리를 JEDIS -\u0026gt; Lettuce 로 변경.  Lettuce 의 경우, 커넥션 풀 없이 사용할 수 있도록 디자인 되어 있어서 선택.      1번 해결방안 시도 후, 어느정도 에러 발생 빈도가 줄어드는 것 같이 보였지만, 특정 시간에 발생하는 레디스 에러는 여전히 있었음.\n 즉 connection pool로 인해 발생된 에러가 아닌듯. 작성된 코드 이슈?  에러가 발생하는 코드 중에, 레디스 키를 expire 하는 부분에 delay를 줌. 또한, SMEMEBER 사용하는 코드를 SSCAN 으로 변경하는 등의 개선 작업 진행.      여전히 발생. 또한 레디스에서 파생된 에러로 인해 Database 까지 전파되는듯 함.\n 해당 에러가 발생하는 시간 대에, 인스턴스 내부에 cronjob 을 수행되나, ssh 를 통한 접근이 불가함을 파악 또한, 해당 시간 전에 AWS EC2 검사 실패가 발생함을 확인. AWS EC2 Reboot 하기로 결정.  서버 off -\u0026gt; redis-save -\u0026gt; ec2 reboot -\u0026gt; redis on 확인 -\u0026gt; 서버 on 과정을 진행 (다행히 5분내에 끝났다.)      Redis 랑 지속적으로 커넥션을 맺고 있는 서버 내림(에러 발생 원인을 명확하게 하기 위해).\n AWS EC2 Detailed monitoring 활성화. 그래도 에러 발생 (AWS EC2 instance 검사 실패, 인스턴스 접속 불가, Redis monioring 접근 불가) 네크워크 이슈? AWS EC2 stop -\u0026gt; start를 통해 호스트 변경. 다행스럽게도 해결    5. 정리  발생한 이슈는 AWS EC2 Instacne 이슈였던듯 싶음. 지금 되돌아보면, 몇가지 시그널을 있었던 듯. (네트워크 관련..) 이중화.. 구조의 필요성을 느꼈음.  하나가 장애가 나더라도, 바로 대체할 수 있도록.    6. 참고  https://jihooyim1.gitbooks.io/linuxbasic/content/contents/08.html https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-lifecycle.html#lifecycle-differences https://redis.io/commands/  ","permalink":"https://102092.github.io/posts/bug/aws-ec2-instance-issue/","summary":"1. 버그 내용  특정 시간만 되면 혹은 간헐적이나 지속적으로, Redis 운영에 장애가 생김. (약 10분 ~ 20분) Error Log -\u0026gt; ... Redis command timed out;  로그 내용으로 보아, 어떠한 이유에서 인 지 레디스 멈췄고, 다른 작업들을 처리하지 못해서 생기는 이슈 같음.    2. 생각해볼 수 있는 원인   특정 작업을 처리하는 데, 시간이 오래 걸려서, 레디스에서 병목이 생기는거 아닐까?\n slow log 찾아볼 것 SLOWLOG subcommand    특정 시간에 너무 많은 키가 expire 되어서 발생한 문제가 아닐까?","title":"AWS EC2 instance issue"},{"content":"1. 버그 내용  내용만 보면, storage engine 에서 auto-increment value를 읽는 데 실패했다는 오류. 아마도 해당 값이 잘못된 값을 읽어오려고 해서 발생하는 버그이지 않을까 싶음.  2. 검색  Failed to read auto-increment value from storage engine 해결 방법 이 바로 나옴. 현재 테이블의 auto-increment 상태값이 잘못 설정되어 있어서, 오류가 발생하는 것.  즉 현재 row 갯수 + 1 이 아닌, 다른 값(0..) 이 들어가 있는 현상이 발생하기도 하는듯.   테이블 상태값 확인 show table status like \u0026#39;테이블명\u0026#39;  강제로 최신 id값을 가진 row를 추가를 통해, 테이블 상태값 변경 insert into table (pk필드) values (최신 PK +1)  그렇지만 현재 상황하고는 안 맞는듯 하다.  왜? 테이블 상태값을 확인했을 때, 잘못된 값이 설정되어 있는 것 처럼 보이지 않는다.   그것보다, 해당 id 값이 42..억이 넘는다  아마도 테이블에 id 타입이 int로 선언되어 있고, 최대치에 도달했기 때문에 발생하지 않을까?    2.1 INT vs BIGINT  위 이미지에서도 볼 수 있듯이, unsigned int 데이터 타입의 최대 value는 약 43억. auto-increment 에 저장되는 값이, 이 한계치를 초과했기 때문에 발생한 문제로 여겨진다. 참고  3. 해결 방법 1. 문제 발생하는 테이블(A)을 카피하여 새로운 테이블(B) 생성 2. 새로운 테이블(B)의 id column 타입 변경 3. 새로운 테이블(B)의 이름을 (A) 로 변경 4. A 테이블 드랍  이 방법이 production 환경에서, 할 수 있는 최선이지 않을까.. mysql int to bigint로 더 검색해보자 참고  4. 정리  MySQL에서 DB스키마 작성시 주의할 점들 테이블을 만들기 전에, 이 포스팅을 한번 참조해보면 좋을 것 같음.   ID값은 BIGINT를 추천한다. 나중에 서비스가 커져 INT를 BIGINT로 바꾸는 경우도 생각보다 만만치 않다. 고려할 점이 생긴다. 마음 편히 BIGINT로 ID를 지정하여 추후에 있을지도 모를 업무를 줄여야 한다.\n  특히 테이터 삽입이 잦은 테이블이라면, 미리 id의 데이터 타입을 BIGINT로 잡고 가는 것도 나쁘지는 않을 것 같다는 생각이 듬.  ","permalink":"https://102092.github.io/posts/bug/fail-to-read-auto-increment-value/","summary":"1. 버그 내용  내용만 보면, storage engine 에서 auto-increment value를 읽는 데 실패했다는 오류. 아마도 해당 값이 잘못된 값을 읽어오려고 해서 발생하는 버그이지 않을까 싶음.  2. 검색  Failed to read auto-increment value from storage engine 해결 방법 이 바로 나옴. 현재 테이블의 auto-increment 상태값이 잘못 설정되어 있어서, 오류가 발생하는 것.  즉 현재 row 갯수 + 1 이 아닌, 다른 값(0..) 이 들어가 있는 현상이 발생하기도 하는듯.   테이블 상태값 확인 show table status like \u0026#39;테이블명\u0026#39;  강제로 최신 id값을 가진 row를 추가를 통해, 테이블 상태값 변경 insert into table (pk필드) values (최신 PK +1)  그렇지만 현재 상황하고는 안 맞는듯 하다.","title":"Failed to read auto-increment value from storage engine"},{"content":"!! ?  ! 는 많이 봤는데.. !! 는 생소하다.  전자는 기본적으로 boolean 값을 반전하는 역할을 담당함.   영어 이름은.. double exclamation  사용 목적  명시적으로 형 변환을 하기 위해 즉 다른 타입의 데이터를 boolean 타입으로 변환해서 판단하기 위해서임.  왜 사용하는가?  undefined , null 값에 대한 condition check를 위해서 사용하는 것이 아닐까 생각함.  예시 var case1; // undefined  console.log(\u0026#34;case1 : \u0026#34; + (case1)); // undefined  console.log(\u0026#34;!case1 : \u0026#34; + (!case1)); // true  console.log(\u0026#34;!!case1: \u0026#34; + (!!case1)); // false  var case2 = true; // 불리언 데이터  console.log(\u0026#34;case2 : \u0026#34; + (case2)); // true  console.log(\u0026#34;!case2 : \u0026#34; + (!case2)); // false  console.log(\u0026#34;!!case2: \u0026#34; + (!!case2)); // true  var case3 = null; // null  console.log(\u0026#34;case3 : \u0026#34; + (case3)); // null, Boolean(null) -\u0026gt; false  console.log(\u0026#34;!case3 : \u0026#34; + (!case3)); // true  console.log(\u0026#34;!!case3: \u0026#34; + (!!case3)); // false   javascript 논리연산자 (NOT) 은 입력값을 boolean 으로 변환하여 true 이면 반전되어 false 를 반환, false 면 true 값을 반환함.  Boolean 참  False  var bNoParam = new Boolean(); var bZero = new Boolean(0); var bNull = new Boolean(null); var bEmptyString = new Boolean(\u0026#39;\u0026#39;); var bfalse = new Boolean(false); var bUndefined = new Boolean(undefined);  True  var btrue = new Boolean(true); var btrueString = new Boolean(\u0026#39;true\u0026#39;); var bfalseString = new Boolean(\u0026#39;false\u0026#39;); var bSuLin = new Boolean(\u0026#39;Su Lin\u0026#39;); var bArrayProto = new Boolean([]); var bObjProto = new Boolean({}); 참고  https://ifuwanna.tistory.com/278 https://penguingoon.tistory.com/178 https://brianflove.com/2014-09-02/whats-the-double-exclamation-mark-for-in-javascript/#:~:text=If%20you%20have%20ever%20noticed,(true%20or%20false)%20value. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean  ","permalink":"https://102092.github.io/posts/javascript/double-exclamation/","summary":"!! ?  ! 는 많이 봤는데.. !! 는 생소하다.  전자는 기본적으로 boolean 값을 반전하는 역할을 담당함.   영어 이름은.. double exclamation  사용 목적  명시적으로 형 변환을 하기 위해 즉 다른 타입의 데이터를 boolean 타입으로 변환해서 판단하기 위해서임.  왜 사용하는가?  undefined , null 값에 대한 condition check를 위해서 사용하는 것이 아닐까 생각함.  예시 var case1; // undefined  console.log(\u0026#34;case1 : \u0026#34; + (case1)); // undefined  console.","title":"Double exclamation"},{"content":"Rebase root commit git rebase -i --root  참고\n  https://stackoverflow.com/questions/22992543/how-do-i-git-rebase-the-first-commit/23000315  Update commit author   수정하고 싶은 직전 커밋의 Hash 확인\n  git rebase\n  git rebase -i -p 커밋hash  위 명령어 입력할 경우, 해당 해쉬 커밋 이후 부터 모든 커밋이 리베이스 대상이됨.   rebase 모드에서, 수정하고자하는 커밋 상태를 e 로 변경\n  author 수정\n  git commit --amend --author=\u0026quot;사용자명 \u0026lt;이메일\u0026gt;\u0026quot; rebase \u0026ndash;continue  git rebase --continue  참고\n  https://jojoldu.tistory.com/120  ","permalink":"https://102092.github.io/posts/git/git-command/","summary":"Rebase root commit git rebase -i --root  참고\n  https://stackoverflow.com/questions/22992543/how-do-i-git-rebase-the-first-commit/23000315  Update commit author   수정하고 싶은 직전 커밋의 Hash 확인\n  git rebase\n  git rebase -i -p 커밋hash  위 명령어 입력할 경우, 해당 해쉬 커밋 이후 부터 모든 커밋이 리베이스 대상이됨.   rebase 모드에서, 수정하고자하는 커밋 상태를 e 로 변경\n  author 수정\n  git commit --amend --author=\u0026quot;사용자명 \u0026lt;이메일\u0026gt;\u0026quot; rebase \u0026ndash;continue  git rebase --continue  참고","title":"Git command"},{"content":"SELECT 쿼리 실행 순서   작성하는 쿼리문의 순서와, 실제 DB에서 실행되는 순서가 다름.\n  보통 Select query 문법 순서\n SELECT FROM WHERE GROUP BY ORDER BY    실제 실행 순서\n FROM  Sub Query.. 있으면 임시테이블 생성됨.   ON JOIN WHERE GROUP BY HAVING SELECT DISTINCT ORDER BY LIMIT, OFFSET    참고\n https://dion-ko.tistory.com/85 https://daeuungcode.tistory.com/144    MySQL Explain  기본적으로 SELECT, INSERT, DELETE, REPLACE, UPDATE 쿼리문의 실행플랜을 분석하는 데 사용하는 키워드. 해당 쿼리를 실제 실행하는 것은 아니고, 데이터베이스에게 어떻게 실행할 건지 계획을 받아보는 방법임. 아래와 같이 사용함.  EXPLAIN SELECT * FROM foo WHERE foo.bar = \u0026#39;infrastructure as a service\u0026#39; OR foo.bar = \u0026#39;iaas\u0026#39;;  DESCRIBE 라는 방법도 있는 데 이는 Explain이란 동일한 기능인듯.  참고  https://dev.mysql.com/doc/refman/5.7/en/describe.html      Explain 결과 이해하기 table  어떤 테이블에 접근하고 있는지 알려줌.  id  SELECT를 몇번이나 실행하는 지의 숫자를 나타낸 값인듯. 해당 쿼리가 Subquery 또는 Union query를 포함하고 있지 않으면 항상 1의 값을 가짐.  select_type  SELECT Query에 대한 타입 SIMPLE (서브쿼리, 유니온 쿼리 없이 실행된 쿼리) SUBQUERY UNION DERIVED 참고  https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type    partitions  해당 테이블이 파티셔닝 되어있을 경우, 사용되는 필드 NULL 은 해당 쿼리에서 사용되는 테이블이 파티셔닝 되지 않았을을 의미  type   어떻게 해당 테이블에 접근하고 있는가를 나타낸 필드\n  이 필드는 실행될 쿼리의 효율성을 판단하는 데 가장 중요한 필드 임\n  system\n 테이블에 하나의 row만 있을 경우    const\n 테이블에 하나의 매칭된 row만 있을 경우 이 타입은 해당 쿼리가 굉장히 빠르게 실행될 수 있음을 의미    eq_ref\n 조인을 사용할 때 나타나는 타입 이전 테이블과 조인을 할 때, 지금 테이블에서 하나의 로우만이 매칭된다는 의미인듯. Join할 때의 best practice 해당 row가 Prmiary key 혹은 Unique key이면서 NOT NULL인 인덱스 일 경우에 해당 타입이 사용됨.    ref\n 조인을 사용할 때 나타나는 타입 Primary key, Unique key가 아닌 Key와 매칭되는 경우 즉 조인할 때, 하나의 row만으로 되지 않는 경우 만약에 매칭되는 row의 수가 적다면, 이 또한 조인할 경우 좋은 타입이라 말할 수 있음.    ref_or_null\n ref 타입과 비슷 그렇지만 해당 row null 이 포함된 row까지 탐색하고 있다는 뜻임.  SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL;  아무래도 null 까지 탐색 조건에 들어가니, ref 타입보다는 별로이지 않을까.    range\n 인덱스를 사용해서, 특정 row 에 범위 접근할 때 사용되는 타입 Explain 결과 colum 중 key 는 해당 인덱스가 가리키고 있는 column임 =, \u0026lt;\u0026gt;, \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=, IS NULL, \u0026lt;=\u0026gt;, BETWEEN, LIKE, IN(), 연산자를 사용할 때 보통 나타나는 타입임  SELECT * FROM tbl_name WHERE key_column = 10; SELECT * FROM tbl_name WHERE key_column BETWEEN 10 and 20; SELECT * FROM tbl_name WHERE key_column IN (10,20,30); SELECT * FROM tbl_name WHERE key_part1 = 10 AND key_part2 IN (10,20,30);   ALL\n 전체 행 스캔, 테이블에 존재하는 모든 데이터 접근 대부분의 경우, 이 타입은 좋지 않음 그래서 보통 인덱스를 추가하여, 해당 타입의 사용을 피함    index\n 인덱스 풀 스캔 인덱스를 처음 부터 끝까지 검색하는 경우 이 타입도 좋지 않음.    참고\n https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types    possible_keys  사용 가능성이 있는 인덱스 목록을 말함.  key  possible_keys 항목 중에, 실제 옵티마이저가 사용하겠다고 선택한 인덱스를 의미. 만약 컬럼이 null 이면, 인덱스를 사용할 수 없다는 의미인듯.  key_len  key 필드 인덱스의 길이를 의미. 너무 길면 비효율적이다.  rows  이 전 컬럼들의 접근방식들을 이용하여, 데이터베이스에서 몇개의 row를 가지고 왔는지 의미하는 컬럼 실제 행 수와는 반드시 일치하지는 않는다.  filtered  rows 컬럼의 값이, WHERE 조건을 거쳤을 경우, 몇행이나 남아있는지 알려주는 컬럼. 실제 행 수와는 반드시 일치하지는 않는다.  extra   옵티마이저가 어떻게 동작할 지 알려주는 힌트.\n  이 컬럼이 Using filesort 나 Using Temporary 라는 값이면 해당 쿼리 실행에 성능적인 문제가 있을 수도 있음을 암시한다.\n  Using filesort\n ORDERB BY 조건에 있는 index를 사용할 수 없을 때, 해당 데이터의 정렬을 위해서, MySQL이 추가적인 작업이 필요함을 의미함. 모든 row를 읽고, sort key를 저장한다음에, 정렬하는 작업이 발생함. sort_buffer_size 만큼의 메모리 할당등이 필요하므로.. 엄청나게 많은 rows가 filesort 과정을 거친다면 데이터베이스에 부담이 될 수 있을듯. 참고  https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html      Using temporary\n 이 쿼리를 위해, 임시적인 테이블 생성이 필요함을 의미. 보통 이 힌트는, 해당 쿼리의 GROUP BY 와 ORDER BY가 포함되어 있고, 다른 컬럼을 가르킬 경우 발생함.    Using where\n where 조건을 이용하여, rows 행을 filterd 하였음을 의미. type 이 ALL 혹은 index 타입이라면, 해당 쿼리에 뭔가 문제가 있다는 의미    Using index\n 인덱스만을 가지고, 데이터를 추출했음을 의미함. InnoDB 의 경우, user-defined clustered index 를 가지고 있으면 그 인덱스가 Extra 에 나타나있지 않더라도, 사용되어질 수 있음. 단 그 type 은 index 이고, key 가 Primary일 경우    MySQL의 index 사용  참고  https://stackoverflow.com/questions/586381/mysql-not-using-indexes-with-where-in-clause    참고  https://www.exoscale.com/syslog/explaining-mysql-queries/#:~:text=In%20MySQL%2C%20EXPLAIN%20can%20be,as%20a%20service'%20OR%20foo. https://cheese10yun.github.io/mysql-explian/ https://www.eversql.com/mysql-explain-example-explaining-mysql-explain-using-stackoverflow-data/ https://nomadlee.com/mysql-explain-sql/ https://www.sitepoint.com/using-explain-to-write-better-mysql-queries/#:~:text=Extra%20%E2%80%93%20contains%20additional%20information%20regarding,may%20indicate%20a%20troublesome%20query  ","permalink":"https://102092.github.io/posts/database/how-to-use-explain-keyword/","summary":"SELECT 쿼리 실행 순서   작성하는 쿼리문의 순서와, 실제 DB에서 실행되는 순서가 다름.\n  보통 Select query 문법 순서\n SELECT FROM WHERE GROUP BY ORDER BY    실제 실행 순서\n FROM  Sub Query.. 있으면 임시테이블 생성됨.   ON JOIN WHERE GROUP BY HAVING SELECT DISTINCT ORDER BY LIMIT, OFFSET    참고\n https://dion-ko.tistory.com/85 https://daeuungcode.tistory.com/144    MySQL Explain  기본적으로 SELECT, INSERT, DELETE, REPLACE, UPDATE 쿼리문의 실행플랜을 분석하는 데 사용하는 키워드.","title":"How to use EXPLAIN in mysql"}]
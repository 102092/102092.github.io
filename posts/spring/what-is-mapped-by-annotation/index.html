<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Mapped By | 나뭇가지</title>
<meta name=keywords content="JPA,Spring">
<meta name=description content="1. 어디까지 알고 있는가?  mapped by 보통 연관관계 매핑에서 사용되며, 연관 관계에서 어느쪽이 주도권을 가지고 있는 지 나타날 떄 쓰이는 어노테이션. 어노테이션에 이 속성이 붙어있는 경우, 해당 필드는 주도권을 가지고 있지 않음.  이 속성이 없는 쪽에서, 연관 관계를 관리한다고 보면 된다. 즉 이 속성이 없는 쪽에서 생성, 업데이트를 해줘야 적용된다.    2. 내가 생각한게 맞는가?  아래와 같이 Entity 가 존재한다고 할 때..  @Entity public class Person { @Id @GeneratedValue(strategy = GenerationType.">
<meta name=author content="Han">
<link rel=canonical href=https://102092.github.io/posts/spring/what-is-mapped-by-annotation/>
<meta name=google-site-verification content="G-M00DV5S2CX">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.9f1d947375927e9847272b1f4e9be81336f539e513bf04d52cade31f81cad1af.css integrity="sha256-nx2Uc3WSfphHJysfTpvoEzb1OeUTvwTVLK3jH4HK0a8=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://102092.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://102092.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://102092.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://102092.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://102092.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<meta property="og:title" content="Mapped By">
<meta property="og:description" content="1. 어디까지 알고 있는가?  mapped by 보통 연관관계 매핑에서 사용되며, 연관 관계에서 어느쪽이 주도권을 가지고 있는 지 나타날 떄 쓰이는 어노테이션. 어노테이션에 이 속성이 붙어있는 경우, 해당 필드는 주도권을 가지고 있지 않음.  이 속성이 없는 쪽에서, 연관 관계를 관리한다고 보면 된다. 즉 이 속성이 없는 쪽에서 생성, 업데이트를 해줘야 적용된다.    2. 내가 생각한게 맞는가?  아래와 같이 Entity 가 존재한다고 할 때..  @Entity public class Person { @Id @GeneratedValue(strategy = GenerationType.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://102092.github.io/posts/spring/what-is-mapped-by-annotation/"><meta property="og:image" content="https://avatars.githubusercontent.com/u/71244638?v=4"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-08T00:00:00+00:00">
<meta property="article:modified_time" content="2021-09-08T00:00:00+00:00"><meta property="og:site_name" content="나뭇가지">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://avatars.githubusercontent.com/u/71244638?v=4">
<meta name=twitter:title content="Mapped By">
<meta name=twitter:description content="1. 어디까지 알고 있는가?  mapped by 보통 연관관계 매핑에서 사용되며, 연관 관계에서 어느쪽이 주도권을 가지고 있는 지 나타날 떄 쓰이는 어노테이션. 어노테이션에 이 속성이 붙어있는 경우, 해당 필드는 주도권을 가지고 있지 않음.  이 속성이 없는 쪽에서, 연관 관계를 관리한다고 보면 된다. 즉 이 속성이 없는 쪽에서 생성, 업데이트를 해줘야 적용된다.    2. 내가 생각한게 맞는가?  아래와 같이 Entity 가 존재한다고 할 때..  @Entity public class Person { @Id @GeneratedValue(strategy = GenerationType.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://102092.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Mapped By","item":"https://102092.github.io/posts/spring/what-is-mapped-by-annotation/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mapped By","name":"Mapped By","description":"1. 어디까지 알고 있는가?  mapped by 보통 연관관계 매핑에서 사용되며, 연관 관계에서 어느쪽이 주도권을 가지고 있는 지 나타날 떄 쓰이는 어노테이션. 어노테이션에 이 속성이 붙어있는 경우, 해당 필드는 주도권을 가지고 있지 않음.  이 속성이 없는 쪽에서, 연관 관계를 관리한다고 보면 된다. 즉 이 속성이 없는 쪽에서 생성, 업데이트를 해줘야 적용된다.    2. 내가 생각한게 맞는가?  아래와 같이 Entity 가 존재한다고 할 때..  @Entity public class Person { @Id @GeneratedValue(strategy = GenerationType.","keywords":["JPA","Spring"],"articleBody":"1. 어디까지 알고 있는가?  mapped by 보통 연관관계 매핑에서 사용되며, 연관 관계에서 어느쪽이 주도권을 가지고 있는 지 나타날 떄 쓰이는 어노테이션. 어노테이션에 이 속성이 붙어있는 경우, 해당 필드는 주도권을 가지고 있지 않음.  이 속성이 없는 쪽에서, 연관 관계를 관리한다고 보면 된다. 즉 이 속성이 없는 쪽에서 생성, 업데이트를 해줘야 적용된다.    2. 내가 생각한게 맞는가?  아래와 같이 Entity 가 존재한다고 할 때..  @Entity public class Person { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int id; private String name; @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL) private ListAddress addresses } @Entity public class Address { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int id; private String street; private int houseNumber; private String city; private int zipCode; @ManyToOne(fetch = FetchType.LAZY) private Person person; }   우선 알고 있는 바를 토대로..\n  Person - Address 는 1대 다 관계\n  List addresses 에 mappedBy 속성 붙어 있으므로, 해당 관계에서 주도권은 Address가 갖는다\n  즉 Address Entity 생성 시에, Address.person에 알맞은 Entity를 set 하고 생성 및 업데이트 해야만, Person.addresses 에서 조회가 가능할 것임.\n 외래키 (forien key) 는 Address 에서 관리될 것이고..    mapped by 되었다라는 의미는,\n ...it tells hibernate not to map this field. it's already mapped by this field [name=\"field\"]... hibernate한테, 이 필드에 대해 map 하지 말라. 이 필드는 이미 person 이라는 이름으로 맵핑된 상태다. 위 예시를 보면, List addresses 필드는 이미 Address Entity 에서 person 이라는 이름으로 맵핑된 상태다.    참고\n https://kok202.tistory.com/138 https://stackoverflow.com/questions/9108224/can-someone-explain-mappedby-in-jpa-and-hibernate    3. OneToMany의 다른 속성들  cascade\n /** * (Optional) The operations that must be cascaded to * the target of the association. *  Defaults to no operations being cascaded. * *  When the target collection is a {@link java.util.Map * java.util.Map}, the cascade element applies to the * map value. */ CascadeType[] cascade() default {};   cascade , 폭포, 매달리다, 흐르다..\n 아마도 뭔가 연결성, 전파성, 종속성을 의미하는 단어인듯.    optional 하고,\n  default 값은 어떠한 행동도 cascade 되지 않을 것.\n  CascadeType 은 ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH\n ALL : 모든 작업(ALL 이하) 상위에서 하위 엔티티로 전파됨. PERSIST : 상위 엔티티가 Persist 되면 (저장) 하위 엔티티도 Persist 됨. (변경 감지 x) MERGE : 변경 감지가 가능한 상태인 상위 엔티티 MERGE (update) 되면 하위 엔티티의 변경 사항도 update 되는듯 REMOVE : 상위 엔티티를 삭제하면, 이에 연결된 하위 엔티티도 삭제 되는 것. JPA에서 제공하는 CascadeType.DELETE 과 차이가 없는 듯. REFRESH : reread the value of a given instance from the database, 즉 데이터베이스에서, 인스턴스에 해당하는 값을 다시 읽어오는 것. 즉 부모 엔티티 값이 갱신되면, 자식 엔티티도 갱신되어짐이 기대된다. DETACH : 상위 엔티티가 persistent context 에서 제거 되면, 하위 엔티티도 제거된다.    참고\n https://www.baeldung.com/jpa-cascade-types    4. 궁금한 점  그럼 mappedBy 된 필드에, 추가 혹은 업데이트 시 반영되지 않는가?\n  생각해보면, 우선 mappedBy 되어 있으면, 추가 업데이트 시에 반영되지 않을 것 같음. 그런데, cascade 옵션이 추가적으로 적혀 있으면 반영될 것 같음. CascadeType.PERSIST를 함부로 사용하면 안되는 이유 라는 포스팅을 보면, 그에 대한 답이 있는듯.  cascdeType이 적용되어 있으면, 해당 타입에 따라 mappedBy 관계로 맺어진 엔티티라도, 부모 엔티티에 적용된 operation 이 연쇄적으로 퍼질 수 있는듯. 즉 mappedBy 로 의존 관계의 owner 를 설정해뒀어도, cascde option 에 따라, 해당 엔티티의 추가 및 업데이트가 실행될 수 있는듯.    5. 테스트  Person, Address Entity. 관계는 1번에 정의된 1 : 다 관계. Person이 가지고 있는 List addresses 에 mappedBy + CascadeType 을 조정하면서 실행.  5.1 persist operation @Test public void testPersist() { Person person = new Person(); Address address = new Address(); person.setAddresses(Arrays.asList(address)); session.persist(person); session.flush(); session.clear(); }  CascadeType.ALL\n ... Hibernate: insert into Person (name, id) values (?, ?) Hibernate: insert into Address (city, houseNumber, person_id, street, zipCode, id) values (?, ?, ?, ?, ?, ?)  Person.address 는 mappedBy 로 묶여 있지만, CascadeType.ALL 로 옵션이 있기에, 부모 엔티티 (Person) 의 persist operation 이 자식 엔티티 (Address) 로 전파됨을 확인.   CascadeType.MERGE\n Hibernate: insert into Person (name, id) values (?, ?)  Persist 외 상황에서는 적용되지 않음을 확인 하나만 더보자.  5.2 merge operation @Test public void testMerge() { int pId; Person person = buildPerson(\"devender\"); Address address = buildAddress(person); person.setAddresses(Arrays.asList(address)); address.setPerson(person); session.persist(person); session.persist(address); session.flush(); pId = person.getId(); session.clear(); Person savedPersonEntity = session.find(Person.class, pId); Address savedAddressEntity = savedPersonEntity.getAddresses().get(0); savedPersonEntity.setName(\"devender kumar\"); savedAddressEntity.setHouseNumber(24); session.merge(savedPersonEntity); session.flush(); } private Address buildAddress(Person person) { Address address = new Address(); address.setCity(\"Berlin\"); address.setHouseNumber(23); address.setStreet(\"Zeughofstraße\"); address.setZipCode(123001); address.setPerson(person); return address; } private Person buildPerson(String name) { Person person = new Person(); person.setName(name); return person; }  CascadeType.MERGE\n Hibernate: update Person set name=? where id=? Hibernate: update Address set city=?, houseNumber=?, person_id=?, street=?, zipCode=? where id=?  savedPersonEntity 만 merge를 실행했지만, 이 operation이 Address에도 전파됨을 알 수 있다. 만약에 savedAddressEntity.setPerson(..) 으로 업데이트가 아닌 Persist operation 을 유도하면?  Person savedPersonEntity = session.find(Person.class, pId); Address savedAddressEntity = savedPersonEntity.getAddresses().get(0); savedPersonEntity.setName(\"devender kumar\"); // savedAddressEntity.setHouseNumber(24);  savedAddressEntity.setPerson(buildPerson(\"newPerson\")); session.merge(savedPersonEntity); session.flush();  결과적으로 에러로그를 볼 수 있다.  java.lang.IllegalStateException: org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: com.baeldung.cascading.domain.Person  Object 의 참조값이, 저장되지 않은 transient instance 이다. 아마도 Persistent context 에서 관리되지 않는 객체라는 의미인듯 싶다.  5.3 Only mappedBy  만약에 mappedBy 만 정의되어 있다면?   persist\n Hibernate: insert into Person (name, id) values (?, ?)  Person 엔티티만 생성됨을 알 수 있다 (persist operation 이 전파가 안된다.)   merge\n Hibernate: update Person set name=? where id=? Hibernate: update Address set city=?, houseNumber=?, person_id=?, street=?, zipCode=? where id=?  로그 상으로는 Person 엔티티 업데이트 시, Address로 전파된다. 전파가 되지 않을 것을 기대했는데, 전파된다. 이게 맞나? (좀 더 찾아봐야 할듯) JPA Managed entities merge operations without cascade options 이 글로 살펴보았을 때, 전파가 된다기 보다는, Person이 Persistent context에 들어가면서, 그 내부에 있는 객체들도 모두 관리 대상이 되었고, 그 관리 대상 중에 업데이트가 일어나서 자연스럽게 업데이트가 쳐진듯?   remove\n @Test public void testRemove() { int personId; Person person = buildPerson(\"devender\"); Address address = buildAddress(person); person.setAddresses(Arrays.asList(address)); address.setPerson(person); session.persist(person); session.persist(address); session.flush(); personId = person.getId(); session.clear(); Person savedPersonEntity = session.find(Person.class, personId); session.remove(savedPersonEntity); session.flush(); }  하나만 더보자. 만약에 전파가 일어난다고 하면 어떻게 될까? savedPersonEntity를 삭제하려면, address에서 해당 person id를 가지고 있는 address entity를 모두 삭제하고 그리고 savePersonEntity가 삭제되어야하나? 너무 생각할게 많아지고 복잡한 느낌. 아마 안될듯.  Hibernate: delete from Person where id=? [2021-09-09 22:57:24,493]-[main] WARN org.hibernate.engine.jdbc.spi.SqlExceptionHelper - SQL Error: 23503, SQLState: 23503 [2021-09-09 22:57:24,493]-[main] ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - Referential integrity constraint violation: \"FKDU13RL17O4H24M9GT7B2BDOBO: PUBLIC.ADDRESS FOREIGN KEY(PERSON_ID) REFERENCES PUBLIC.PERSON(ID) (1)\"; SQL statement:   에러 내용으로 보아, savedPersonEntity 를 삭제하려 했는데, Address 테이블의 Forein Key(PERSON ID) 를 참조하고 있는게 발견되어서, 삭제하지 못했다는 뜻.\n  전파..되는 것 같진 않다.\n  참고\n eugenp/tutorials/persistence-modules/jpa-hibernate-cascade-type/    6. 정리  정리해보자면, mappedBy는 외래키를 어디서 관리하냐 정도 의미 인듯. mappedBy가 붙어 있으면 해당 엔티티에서 관리하진 않고, 상대편 엔티티에서 관리하는듯 mappedBy + cascadeType 이 같이 있으면, 해당 엔티티에 추가, 업데이트 될 시 트랜잭션 끝나는 시점에 쿼리 날라갈 수 있음. 즉 mappedBy 는 엔티티 간 관계만 나타낼 뿐, Persistent Context에서 관리하는 건 똑같으니까, 이 객체에 변화(merge) 가 있을 경우 업데이트가 날라갈 수도 있다. 조심해서 사용해야할듯함.  ","wordCount":"1066","inLanguage":"en","datePublished":"2021-09-08T00:00:00Z","dateModified":"2021-09-08T00:00:00Z","author":{"@type":"Person","name":"Han"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://102092.github.io/posts/spring/what-is-mapped-by-annotation/"},"publisher":{"@type":"Organization","name":"나뭇가지","logo":{"@type":"ImageObject","url":"https://102092.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://102092.github.io accesskey=h title="나뭇가지 (Alt + H)">나뭇가지</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://102092.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://102092.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://102092.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://102092.github.io>Home</a>&nbsp;»&nbsp;<a href=https://102092.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Mapped By
</h1>
<div class=post-meta>September 8, 2021&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Han&nbsp;|&nbsp;<a href=https://github.com/102092/102092.github.io/blob/dev/content/posts/spring/what-is-mapped-by-annotation.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><h1 id=1-어디까지-알고-있는가>1. 어디까지 알고 있는가?<a hidden class=anchor aria-hidden=true href=#1-어디까지-알고-있는가>#</a></h1>
<ul>
<li><code>mapped by</code> 보통 연관관계 매핑에서 사용되며, 연관 관계에서 어느쪽이 주도권을 가지고 있는 지 나타날 떄 쓰이는 어노테이션.</li>
<li>어노테이션에 이 속성이 붙어있는 경우, 해당 필드는 주도권을 가지고 있지 않음.
<ul>
<li>이 속성이 없는 쪽에서, 연관 관계를 관리한다고 보면 된다.</li>
<li>즉 이 속성이 없는 쪽에서 생성, 업데이트를 해줘야 적용된다.</li>
</ul>
</li>
</ul>
<h1 id=2-내가-생각한게-맞는가>2. 내가 생각한게 맞는가?<a hidden class=anchor aria-hidden=true href=#2-내가-생각한게-맞는가>#</a></h1>
<ul>
<li>아래와 같이 Entity 가 존재한다고 할 때..</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#a6e22e>@Entity</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Id</span>
    <span style=color:#a6e22e>@GeneratedValue</span><span style=color:#f92672>(</span>strategy <span style=color:#f92672>=</span> GenerationType<span style=color:#f92672>.</span><span style=color:#a6e22e>AUTO</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> id<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> String name<span style=color:#f92672>;</span>
    <span style=color:#a6e22e>@OneToMany</span><span style=color:#f92672>(</span>mappedBy <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;person&#34;</span><span style=color:#f92672>,</span> cascade <span style=color:#f92672>=</span> CascadeType<span style=color:#f92672>.</span><span style=color:#a6e22e>ALL</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>private</span> List<span style=color:#f92672>&lt;</span>Address<span style=color:#f92672>&gt;</span> addresses
<span style=color:#f92672>}</span>

<span style=color:#a6e22e>@Entity</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Address</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Id</span>
    <span style=color:#a6e22e>@GeneratedValue</span><span style=color:#f92672>(</span>strategy <span style=color:#f92672>=</span> GenerationType<span style=color:#f92672>.</span><span style=color:#a6e22e>AUTO</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> id<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> String street<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> houseNumber<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> String city<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> zipCode<span style=color:#f92672>;</span>
    <span style=color:#a6e22e>@ManyToOne</span><span style=color:#f92672>(</span>fetch <span style=color:#f92672>=</span> FetchType<span style=color:#f92672>.</span><span style=color:#a6e22e>LAZY</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>private</span> Person person<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><ul>
<li>
<p>우선 알고 있는 바를 토대로..</p>
</li>
<li>
<p>Person - Address 는 1대 다 관계</p>
</li>
<li>
<p><code>List&lt;Address> addresses</code> 에 mappedBy 속성 붙어 있으므로, 해당 관계에서 주도권은 <code>Address</code>가 갖는다</p>
</li>
<li>
<p>즉 <code>Address</code> Entity 생성 시에, Address.person에 알맞은 Entity를 set 하고 생성 및 업데이트 해야만, <code>Person.addresses</code> 에서 조회가 가능할 것임.</p>
<ul>
<li>외래키 (forien key) 는 <code>Address</code> 에서 관리될 것이고..</li>
</ul>
</li>
<li>
<p><code>mapped by</code> 되었다라는 의미는,</p>
<ul>
<li><code>...it tells hibernate not to map this field. it's already mapped by this field [name="field"]...</code></li>
<li>hibernate한테, 이 필드에 대해 map 하지 말라. 이 필드는 이미 <code>person</code> 이라는 이름으로 맵핑된 상태다.</li>
<li>위 예시를 보면, <code>List&lt;Address> addresses</code> 필드는 이미 <code>Address</code> Entity 에서 <code>person</code> 이라는 이름으로 맵핑된 상태다.</li>
</ul>
</li>
<li>
<p>참고</p>
<ul>
<li><a href=https://kok202.tistory.com/138>https://kok202.tistory.com/138</a></li>
<li><a href=https://stackoverflow.com/questions/9108224/can-someone-explain-mappedby-in-jpa-and-hibernate>https://stackoverflow.com/questions/9108224/can-someone-explain-mappedby-in-jpa-and-hibernate</a></li>
</ul>
</li>
</ul>
<h1 id=3-onetomany의-다른-속성들>3. OneToMany의 다른 속성들<a hidden class=anchor aria-hidden=true href=#3-onetomany의-다른-속성들>#</a></h1>
<blockquote>
<p><em>cascade</em></p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#75715e>/** 
</span><span style=color:#75715e>    * (Optional) The operations that must be cascaded to 
</span><span style=color:#75715e>    * the target of the association.
</span><span style=color:#75715e>    * &lt;p&gt; Defaults to no operations being cascaded.
</span><span style=color:#75715e>    *
</span><span style=color:#75715e>    * &lt;p&gt; When the target collection is a {@link java.util.Map
</span><span style=color:#75715e>    * java.util.Map}, the &lt;code&gt;cascade&lt;/code&gt; element applies to the
</span><span style=color:#75715e>    * map value.
</span><span style=color:#75715e>    */</span>
   CascadeType<span style=color:#f92672>[]</span> <span style=color:#a6e22e>cascade</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>default</span> <span style=color:#f92672>{};</span>
</code></pre></div><ul>
<li>
<p><a href=https://en.dict.naver.com/#/entry/enko/404e7935c8494e448e4991c5096de246>cascade</a> , 폭포, 매달리다, 흐르다..</p>
<ul>
<li>아마도 뭔가 연결성, 전파성, 종속성을 의미하는 단어인듯.</li>
</ul>
</li>
<li>
<p><code>optional</code> 하고,</p>
</li>
<li>
<p><code>default</code> 값은 어떠한 행동도 cascade 되지 않을 것.</p>
</li>
<li>
<p><code>CascadeType</code> 은 ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH</p>
<ul>
<li>ALL : 모든 작업(ALL 이하) 상위에서 하위 엔티티로 전파됨.</li>
<li>PERSIST : 상위 엔티티가 Persist 되면 (저장) 하위 엔티티도 Persist 됨. (변경 감지 x)</li>
<li>MERGE : 변경 감지가 가능한 상태인 상위 엔티티 MERGE (update) 되면 하위 엔티티의 변경 사항도 update 되는듯</li>
<li>REMOVE : 상위 엔티티를 삭제하면, 이에 연결된 하위 엔티티도 삭제 되는 것. JPA에서 제공하는 <code>CascadeType.DELETE</code> 과 차이가 없는 듯.</li>
<li>REFRESH : reread the value of a given instance from the database, 즉 데이터베이스에서, 인스턴스에 해당하는 값을 다시 읽어오는 것. 즉 부모 엔티티 값이 갱신되면, 자식 엔티티도 갱신되어짐이 기대된다.</li>
<li>DETACH : 상위 엔티티가 <code>persistent context</code> 에서 제거 되면, 하위 엔티티도 제거된다.</li>
</ul>
</li>
<li>
<p>참고</p>
<ul>
<li><a href=https://www.baeldung.com/jpa-cascade-types>https://www.baeldung.com/jpa-cascade-types</a></li>
</ul>
</li>
</ul>
<h1 id=4-궁금한-점>4. 궁금한 점<a hidden class=anchor aria-hidden=true href=#4-궁금한-점>#</a></h1>
<blockquote>
<p><em>그럼 mappedBy 된 필드에, 추가 혹은 업데이트 시 반영되지 않는가?</em></p>
</blockquote>
<ul>
<li>생각해보면, 우선 <code>mappedBy</code> 되어 있으면, 추가 업데이트 시에 반영되지 않을 것 같음.</li>
<li>그런데, <code>cascade</code> 옵션이 추가적으로 적혀 있으면 반영될 것 같음.</li>
<li><a href=https://joont92.github.io/jpa/CascadeType-PERSIST%EB%A5%BC-%ED%95%A8%EB%B6%80%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/>CascadeType.PERSIST를 함부로 사용하면 안되는 이유</a> 라는 포스팅을 보면, 그에 대한 답이 있는듯.
<ul>
<li>cascdeType이 적용되어 있으면, 해당 타입에 따라 mappedBy 관계로 맺어진 엔티티라도, 부모 엔티티에 적용된 operation 이 연쇄적으로 퍼질 수 있는듯.</li>
<li>즉 <code>mappedBy</code> 로 의존 관계의 owner 를 설정해뒀어도, cascde option 에 따라, 해당 엔티티의 추가 및 업데이트가 실행될 수 있는듯.</li>
</ul>
</li>
</ul>
<h1 id=5-테스트>5. 테스트<a hidden class=anchor aria-hidden=true href=#5-테스트>#</a></h1>
<ul>
<li>Person, Address Entity.</li>
<li>관계는 1번에 정의된 1 : 다 관계.</li>
<li>Person이 가지고 있는 <code>List&lt;Address> addresses</code> 에 <code>mappedBy</code> + <code>CascadeType</code> 을 조정하면서 실행.</li>
</ul>
<h2 id=51-persist-operation>5.1 persist operation<a hidden class=anchor aria-hidden=true href=#51-persist-operation>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#a6e22e>@Test</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testPersist</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        Person person <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person<span style=color:#f92672>();</span>
        Address address <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Address<span style=color:#f92672>();</span>
        person<span style=color:#f92672>.</span><span style=color:#a6e22e>setAddresses</span><span style=color:#f92672>(</span>Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span>address<span style=color:#f92672>));</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>person<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>clear</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
</code></pre></div><blockquote>
<p><em>CascadeType.ALL</em></p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>...
Hibernate: insert into Person (name, id) values (?, ?)
Hibernate: insert into Address (city, houseNumber, person_id, street, zipCode, id) values (?, ?, ?, ?, ?, ?)
</code></pre></div><ul>
<li>Person.address 는 <code>mappedBy</code> 로 묶여 있지만, <code>CascadeType.ALL</code> 로 옵션이 있기에, 부모 엔티티 (Person) 의 persist operation 이 자식 엔티티 (Address) 로 전파됨을 확인.</li>
</ul>
<blockquote>
<p><em>CascadeType.MERGE</em></p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>Hibernate: insert into Person (name, id) values (?, ?)
</code></pre></div><ul>
<li>Persist 외 상황에서는 적용되지 않음을 확인</li>
<li>하나만 더보자.</li>
</ul>
<h2 id=52-merge-operation>5.2 merge operation<a hidden class=anchor aria-hidden=true href=#52-merge-operation>#</a></h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#a6e22e>@Test</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testMerge</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>int</span> pId<span style=color:#f92672>;</span>
        Person person <span style=color:#f92672>=</span> buildPerson<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;devender&#34;</span><span style=color:#f92672>);</span>
        Address address <span style=color:#f92672>=</span> buildAddress<span style=color:#f92672>(</span>person<span style=color:#f92672>);</span>
        person<span style=color:#f92672>.</span><span style=color:#a6e22e>setAddresses</span><span style=color:#f92672>(</span>Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span>address<span style=color:#f92672>));</span>
        address<span style=color:#f92672>.</span><span style=color:#a6e22e>setPerson</span><span style=color:#f92672>(</span>person<span style=color:#f92672>);</span>

        session<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>person<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>address<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span>
        pId <span style=color:#f92672>=</span> person<span style=color:#f92672>.</span><span style=color:#a6e22e>getId</span><span style=color:#f92672>();</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>clear</span><span style=color:#f92672>();</span>

        Person savedPersonEntity <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span><span style=color:#a6e22e>find</span><span style=color:#f92672>(</span>Person<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> pId<span style=color:#f92672>);</span>
        Address savedAddressEntity <span style=color:#f92672>=</span> savedPersonEntity<span style=color:#f92672>.</span><span style=color:#a6e22e>getAddresses</span><span style=color:#f92672>().</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>0<span style=color:#f92672>);</span>
        savedPersonEntity<span style=color:#f92672>.</span><span style=color:#a6e22e>setName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;devender kumar&#34;</span><span style=color:#f92672>);</span>
        savedAddressEntity<span style=color:#f92672>.</span><span style=color:#a6e22e>setHouseNumber</span><span style=color:#f92672>(</span>24<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>merge</span><span style=color:#f92672>(</span>savedPersonEntity<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>private</span> Address <span style=color:#a6e22e>buildAddress</span><span style=color:#f92672>(</span>Person person<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      Address address <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Address<span style=color:#f92672>();</span>
      address<span style=color:#f92672>.</span><span style=color:#a6e22e>setCity</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Berlin&#34;</span><span style=color:#f92672>);</span>
      address<span style=color:#f92672>.</span><span style=color:#a6e22e>setHouseNumber</span><span style=color:#f92672>(</span>23<span style=color:#f92672>);</span>
      address<span style=color:#f92672>.</span><span style=color:#a6e22e>setStreet</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Zeughofstraße&#34;</span><span style=color:#f92672>);</span>
      address<span style=color:#f92672>.</span><span style=color:#a6e22e>setZipCode</span><span style=color:#f92672>(</span>123001<span style=color:#f92672>);</span>
      address<span style=color:#f92672>.</span><span style=color:#a6e22e>setPerson</span><span style=color:#f92672>(</span>person<span style=color:#f92672>);</span>
      <span style=color:#66d9ef>return</span> address<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>private</span> Person <span style=color:#a6e22e>buildPerson</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        Person person <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Person<span style=color:#f92672>();</span>
        person<span style=color:#f92672>.</span><span style=color:#a6e22e>setName</span><span style=color:#f92672>(</span>name<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> person<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div><blockquote>
<p><em>CascadeType.MERGE</em></p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>Hibernate: update Person set name=? where id=?
Hibernate: update Address set city=?, houseNumber=?, person_id=?, street=?, zipCode=? where id=?
</code></pre></div><ul>
<li><code>savedPersonEntity</code> 만 merge를 실행했지만, 이 operation이 Address에도 전파됨을 알 수 있다.</li>
<li>만약에 <code>savedAddressEntity.setPerson(..)</code> 으로 업데이트가 아닌 Persist operation 을 유도하면?</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>        Person savedPersonEntity <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span><span style=color:#a6e22e>find</span><span style=color:#f92672>(</span>Person<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> pId<span style=color:#f92672>);</span>
        Address savedAddressEntity <span style=color:#f92672>=</span> savedPersonEntity<span style=color:#f92672>.</span><span style=color:#a6e22e>getAddresses</span><span style=color:#f92672>().</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>0<span style=color:#f92672>);</span>
        savedPersonEntity<span style=color:#f92672>.</span><span style=color:#a6e22e>setName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;devender kumar&#34;</span><span style=color:#f92672>);</span>
<span style=color:#75715e>//        savedAddressEntity.setHouseNumber(24);
</span><span style=color:#75715e></span>        savedAddressEntity<span style=color:#f92672>.</span><span style=color:#a6e22e>setPerson</span><span style=color:#f92672>(</span>buildPerson<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;newPerson&#34;</span><span style=color:#f92672>));</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>merge</span><span style=color:#f92672>(</span>savedPersonEntity<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span>
</code></pre></div><ul>
<li>결과적으로 에러로그를 볼 수 있다.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>java.lang.IllegalStateException: org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: com.baeldung.cascading.domain.Person
</code></pre></div><ul>
<li>Object 의 참조값이, 저장되지 않은 transient instance 이다.</li>
<li>아마도 Persistent context 에서 관리되지 않는 객체라는 의미인듯 싶다.</li>
</ul>
<h2 id=53-only-mappedby>5.3 Only mappedBy<a hidden class=anchor aria-hidden=true href=#53-only-mappedby>#</a></h2>
<ul>
<li>만약에 <code>mappedBy</code> 만 정의되어 있다면?</li>
</ul>
<blockquote>
<p><em>persist</em></p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>Hibernate: insert into Person (name, id) values (?, ?)
</code></pre></div><ul>
<li>Person 엔티티만 생성됨을 알 수 있다 (persist operation 이 전파가 안된다.)</li>
</ul>
<blockquote>
<p><em>merge</em></p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>Hibernate: update Person set name=? where id=?
Hibernate: update Address set city=?, houseNumber=?, person_id=?, street=?, zipCode=? where id=?
</code></pre></div><ul>
<li>로그 상으로는 Person 엔티티 업데이트 시, Address로 전파된다.</li>
<li>전파가 되지 않을 것을 기대했는데, 전파된다. 이게 맞나? (좀 더 찾아봐야 할듯)</li>
<li><a href=https://stackoverflow.com/questions/18377055/jpa-managed-entities-merge-operations-without-cascade-options>JPA Managed entities merge operations without cascade options</a> 이 글로 살펴보았을 때, 전파가 된다기 보다는, Person이 Persistent context에 들어가면서, 그 내부에 있는 객체들도 모두 관리 대상이 되었고, 그 관리 대상 중에 업데이트가 일어나서 자연스럽게 업데이트가 쳐진듯?</li>
</ul>
<blockquote>
<p><em>remove</em></p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#a6e22e>@Test</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>testRemove</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>int</span> personId<span style=color:#f92672>;</span>
        Person person <span style=color:#f92672>=</span> buildPerson<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;devender&#34;</span><span style=color:#f92672>);</span>
        Address address <span style=color:#f92672>=</span> buildAddress<span style=color:#f92672>(</span>person<span style=color:#f92672>);</span>
        person<span style=color:#f92672>.</span><span style=color:#a6e22e>setAddresses</span><span style=color:#f92672>(</span>Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span>address<span style=color:#f92672>));</span>
        address<span style=color:#f92672>.</span><span style=color:#a6e22e>setPerson</span><span style=color:#f92672>(</span>person<span style=color:#f92672>);</span>

        session<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>person<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>persist</span><span style=color:#f92672>(</span>address<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span>
        personId <span style=color:#f92672>=</span> person<span style=color:#f92672>.</span><span style=color:#a6e22e>getId</span><span style=color:#f92672>();</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>clear</span><span style=color:#f92672>();</span>

        Person savedPersonEntity <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span><span style=color:#a6e22e>find</span><span style=color:#f92672>(</span>Person<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> personId<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>remove</span><span style=color:#f92672>(</span>savedPersonEntity<span style=color:#f92672>);</span>
        session<span style=color:#f92672>.</span><span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
</code></pre></div><ul>
<li>하나만 더보자.</li>
<li>만약에 전파가 일어난다고 하면 어떻게 될까?</li>
<li><code>savedPersonEntity</code>를 삭제하려면, address에서 해당 person id를 가지고 있는 address entity를 모두 삭제하고 그리고 savePersonEntity가 삭제되어야하나?</li>
<li>너무 생각할게 많아지고 복잡한 느낌. 아마 안될듯.</li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>Hibernate: delete from Person where id=?
[2021-09-09 22:57:24,493]-[main] WARN  org.hibernate.engine.jdbc.spi.SqlExceptionHelper - SQL Error: 23503, SQLState: 23503
[2021-09-09 22:57:24,493]-[main] ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - Referential integrity constraint violation: &#34;FKDU13RL17O4H24M9GT7B2BDOBO: PUBLIC.ADDRESS FOREIGN KEY(PERSON_ID) REFERENCES PUBLIC.PERSON(ID) (1)&#34;; SQL statement:
</code></pre></div><ul>
<li>
<p>에러 내용으로 보아, <code>savedPersonEntity</code> 를 삭제하려 했는데, Address 테이블의 Forein Key(PERSON ID) 를 참조하고 있는게 발견되어서, 삭제하지 못했다는 뜻.</p>
</li>
<li>
<p>전파..되는 것 같진 않다.</p>
</li>
<li>
<p>참고</p>
<ul>
<li><a href=https://github.com/eugenp/tutorials/tree/master/persistence-modules/jpa-hibernate-cascade-type>eugenp/tutorials/persistence-modules/jpa-hibernate-cascade-type/</a></li>
</ul>
</li>
</ul>
<h1 id=6-정리>6. 정리<a hidden class=anchor aria-hidden=true href=#6-정리>#</a></h1>
<ul>
<li>정리해보자면, <code>mappedBy</code>는 외래키를 어디서 관리하냐 정도 의미 인듯.</li>
<li><code>mappedBy</code>가 붙어 있으면 해당 엔티티에서 관리하진 않고, 상대편 엔티티에서 관리하는듯</li>
<li><code>mappedBy</code> + <code>cascadeType</code> 이 같이 있으면, 해당 엔티티에 추가, 업데이트 될 시 트랜잭션 끝나는 시점에 쿼리 날라갈 수 있음.</li>
<li>즉 <code>mappedBy</code> 는 엔티티 간 관계만 나타낼 뿐, Persistent Context에서 관리하는 건 똑같으니까, 이 객체에 변화(merge) 가 있을 경우 업데이트가 날라갈 수도 있다.</li>
<li>조심해서 사용해야할듯함.</li>
</ul>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://102092.github.io/tags/jpa/>JPA</a></li>
<li><a href=https://102092.github.io/tags/spring/>Spring</a></li>
</ul>
<nav class=paginav>
<a class=next href=https://102092.github.io/posts/bug/aws-ec2-instance-issue/>
<span class=title>Next Page »</span>
<br>
<span>AWS EC2 instance issue</span>
</a>
</nav>
</footer><script src=https://utteranc.es/client.js repo=102092/comments issue-term=title theme=github-light crossorigin=anonymous async></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://102092.github.io>나뭇가지</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>